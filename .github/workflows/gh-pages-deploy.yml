name: Deploy to GitHub Pages

on:
  push:
    branches: [ production ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: gh-pages-deploy
      cancel-in-progress: true
    permissions:
      contents: write
      pages: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: "npm"
      - name: Cache Node Modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            ${{ github.workspace }}/.next/cache
            node_modules
          # Generate a new cache whenever packages or source files change.
          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
          # If source files changed but packages didn't, rebuild from a prior cache.
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-          
      - name: Install dependencies
        run: |
          set -ex
          npm ci

      - name: Validate required secrets
        run: |
          set -e
          echo "Checking required repository secrets (values hidden)..."
          MISSING=0
          check() {
            if [ -z "${1}" ]; then
              echo "✖ ${2}: MISSING" >&2
              MISSING=1
            else
              echo "✔ ${2}: PRESENT"
            fi
          }
          check "${{ secrets.NEXT_PUBLIC_GA_ID }}" NEXT_PUBLIC_GA_ID
          check "${{ secrets.NEXT_PUBLIC_GA_MEASUREMENT_ID }}" NEXT_PUBLIC_GA_MEASUREMENT_ID
          check "${{ secrets.NEXT_PUBLIC_GTM_ID }}" NEXT_PUBLIC_GTM_ID
          check "${{ secrets.NEXT_PUBLIC_SITE_URL }}" NEXT_PUBLIC_SITE_URL
          check "${{ secrets.GA_CLIENT_EMAIL }}" GA_CLIENT_EMAIL
          check "${{ secrets.GA_PRIVATE_KEY }}" GA_PRIVATE_KEY
          check "${{ secrets.GA_VIEW_ID }}" GA_VIEW_ID
          check "${{ secrets.GA_PROPERTY_ID }}" GA_PROPERTY_ID
          check "${{ secrets.ANALYTICS_BACKEND }}" ANALYTICS_BACKEND
          if [ "$MISSING" -eq 1 ]; then
            echo "One or more required secrets are missing. Set them in repository Settings → Secrets → Actions." >&2
            exit 1
          fi
      - name: Build SCSS
        run: |
          set -ex
          npm run scss:build
      # - name: Build (static export) + generate analytics
      #   env:
      #     NEXT_STATIC_EXPORT: 'true'
      #     # Provide GA/GTM and public site config from repo secrets so
      #     # the layout's env-driven script blocks render in the generated HTML.
      #     NEXT_PUBLIC_GA_ID: ${{ secrets.NEXT_PUBLIC_GA_ID }}
      #     NEXT_PUBLIC_GA_MEASUREMENT_ID: ${{ secrets.NEXT_PUBLIC_GA_MEASUREMENT_ID }}
      #     NEXT_PUBLIC_GTM_ID: ${{ secrets.NEXT_PUBLIC_GTM_ID }}
      #     NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
      #     # Include compiled SCSS in CI static export (matches local .env behavior)
      #     NEXT_PUBLIC_INCLUDE_SCSS: 'true'
      #     # Secrets required to run the analytics generator script
      #     GA_CLIENT_EMAIL: ${{ secrets.GA_CLIENT_EMAIL }}
      #     GA_PRIVATE_KEY: ${{ secrets.GA_PRIVATE_KEY }}
      #     GA_VIEW_ID: ${{ secrets.GA_VIEW_ID }}
      #     GA_PROPERTY_ID: ${{ secrets.GA_PROPERTY_ID }}
      #     ANALYTICS_BACKEND: ${{ secrets.ANALYTICS_BACKEND }}
      #   run: |
      #     set -ex
      #     npm run build
      #     npm run generate:analytics
      - name: Deploy `out/` to `gh-pages` branch
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./out
          publish_branch: gh-pages
          user_name: github-actions
          user_email: github-actions@users.noreply.github.com
          cname: sanatanadharmam.in

  sync-branches:
    needs: build-and-deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout current branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up git user
        run: |
          git config user.name github-actions
          git config user.email github-actions@users.noreply.github.com
      - name: Sync branches
        env:
          DRY_RUN: 'false'
        run: |
          set -ex
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
          # fetch both branches to ensure we have the latest refs
          git fetch --no-tags origin +refs/heads/*:refs/remotes/origin/*

          # Helper: if there are unmerged index entries, reset workspace to remote branch
          BRANCH_FROM_REF="${GITHUB_REF##*/}"
          check_and_reset_unmerged() {
            if git ls-files -u | grep -q .; then
              echo "Detected unmerged index entries — resetting to origin/${BRANCH_FROM_REF} to recover"
              git reset --hard origin/${BRANCH_FROM_REF} || true
              git clean -fdx || true
            fi
          }
          check_and_reset_unmerged || true

          # If there's an unmerged/conflicted index (leftover from prior runs),
          # reset and clean to avoid blocking automated merges.
          if git status --porcelain | grep -q "^UU"; then
            echo "Found unmerged files in index — resetting workspace to a clean state"
            git reset --hard || true
            git clean -fdx || true
          fi

          # Ensure generated docs are not present to avoid merge conflicts. Use
          # both rm and rm --cached to cover tracked/untracked cases.
          git rm -r --ignore-unmatch docs || true
          git rm -r --cached --ignore-unmatch docs || true
          git commit -m "ci: remove docs (migrate to gh-pages)" || true

          BRANCH="${GITHUB_REF##*/}"
          echo "Current ref branch: $BRANCH"

          push_with_fallback() {
            local target=$1
            echo "Attempting to push $target..."
            if git push origin "$target"; then
              echo "Push $target succeeded"
            else
              echo "Push $target failed; attempting safe force (force-with-lease)..."
              git push --force-with-lease origin "$target"
            fi
          }

          if [ "$BRANCH" = "development" ]; then
            # Ensure local development has remote changes merged first
            git checkout development
            git reset --hard origin/development || true
            git clean -fdx || true
            git merge --no-edit origin/development || true

            # Merge main into development (prefer their changes when conflicts)
            git reset --hard origin/development || true
            git clean -fdx || true
            git merge origin/main --no-edit -X theirs || true

            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY_RUN is true — skipping push for development"
            else
              push_with_fallback development
            fi

            # Update main from development and push
            git checkout main
            git reset --hard origin/main || true
            git clean -fdx || true
            git merge --no-edit development -X theirs || true
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY_RUN is true — skipping push for main"
            else
              push_with_fallback main
            fi

          elif [ "$BRANCH" = "main" ]; then
            git checkout main
            git reset --hard origin/main || true
            git clean -fdx || true
            git merge --no-edit origin/main || true

            git reset --hard origin/main || true
            git clean -fdx || true
            git merge origin/development --no-edit -X theirs || true
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY_RUN is true — skipping push for main"
            else
              push_with_fallback main
            fi

            git checkout development
            git reset --hard origin/development || true
            git clean -fdx || true
            git merge --no-edit main -X theirs || true
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY_RUN is true — skipping push for development"
            else
              push_with_fallback development
            fi
          else
            echo "Not on main or development branch; skipping branch sync."
          fi
      - name: Confirm sync
        run: echo "Branches development and main are now synced."
